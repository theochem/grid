<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cubic Grids &mdash; grid  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/override.css" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interpolation and Solving Poisson’s Equation" href="interpolation_poisson.html" />
    <link rel="prev" title="Molecular Grids" href="molecular_grid.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/grid_logo_website.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#downloading-code">Downloading Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#id1">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#building-documentation">Building Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../onedgrids.html">One-Dimensional Grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="../radial_transf.html">Radial Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conventions.html">Conventions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#spherical-coordinates">Spherical Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#spherical-harmonics">Spherical Harmonics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../conventions.html#ordering">Ordering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#angular-grids">Angular Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../conventions.html#nested-grids">Nested Grids</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#One-Dimensional-Grids">One-Dimensional Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#Angular-Grids">Angular Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#Atomic-Grid">Atomic Grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#Molecular-Grid">Molecular Grid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="quickstart.html#Visualize-3D-Grid-Points">Visualize 3D Grid Points</a></li>
<li class="toctree-l3"><a class="reference internal" href="quickstart.html#Integrate-Electron-Density-on-the-Grid">Integrate Electron Density on the Grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="quickstart.html#Interpolate-Electron-Density-on-the-Grid">Interpolate Electron Density on the Grid</a><ul>
<li class="toctree-l4"><a class="reference internal" href="quickstart.html#Check-Interpolation-Accuracy">Check Interpolation Accuracy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="quickstart.html#Differentiate-Electron-Density-on-the-Grid">Differentiate Electron Density on the Grid</a><ul>
<li class="toctree-l4"><a class="reference internal" href="quickstart.html#Check-interpolated-derivative-accuracy">Check interpolated derivative accuracy</a></li>
<li class="toctree-l4"><a class="reference internal" href="quickstart.html#Graphical-comparisons-of-the-accuracy">Graphical comparisons of the accuracy</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="one_dimensional_grids.html">One-Dimensional Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="one_dimensional_grids.html#Example:-Visualize-One-Dimensional-Grid-Points">Example: Visualize One-Dimensional Grid Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="one_dimensional_grids.html#Example:-Integration-of-One-Variable-Function-on-[-1,-1]">Example: Integration of One-Variable Function on <span class="math notranslate nohighlight">\([-1, 1]\)</span></a><ul>
<li class="toctree-l3"><a class="reference internal" href="one_dimensional_grids.html#Radial-Grid:-Transformation-of-1D-Integration-Intervals">Radial Grid: Transformation of 1D-Integration Intervals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="one_dimensional_grids.html#Visualize-Radial-Grid-Points">Visualize Radial Grid Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="one_dimensional_grids.html#Example:-Integration-of-One-Variable-Function-on-[0,-\infty]">Example: Integration of One-Variable Function on <span class="math notranslate nohighlight">\([0, \infty]\)</span></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="angular_grid.html">Angular Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="angular_grid.html#Initialization-of-Angular-Grids">Initialization of Angular Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="angular_grid.html#Integral-of-Identity-Function">Integral of Identity Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="angular_grid.html#Integral-of-Spherical-Harmonic-Function">Integral of Spherical Harmonic Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="angular_grid.html#Spherical-Harmonics-Are-Orthonormal">Spherical Harmonics Are Orthonormal</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="atom_grid_construction.html">Atom Grid Construction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="atom_grid_construction.html#Atomic-Grid-AtomGrid">Atomic Grid <code class="docutils literal notranslate"><span class="pre">AtomGrid</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="atom_grid_construction.html#Plot-AtomGrid-Points">Plot <code class="docutils literal notranslate"><span class="pre">AtomGrid</span></code> Points</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="atom_grid_construction.html#Pruned-Grids-AtomGrid.from_pruned">Pruned Grids <code class="docutils literal notranslate"><span class="pre">AtomGrid.from_pruned</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="atom_grid_construction.html#Preset-Grids-AtomGrid.from_preset">Preset Grids <code class="docutils literal notranslate"><span class="pre">AtomGrid.from_preset</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="atom_grid_construction.html#Multiple-Centered-AtomGrids">Multiple Centered AtomGrids</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="atom_grid.html">Atom Grid Application</a><ul>
<li class="toctree-l2"><a class="reference internal" href="atom_grid.html#Construct-Atomic-Grid">Construct Atomic Grid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="atom_grid.html#Example:-Integrate-Electron-Density">Example: Integrate Electron Density</a></li>
<li class="toctree-l3"><a class="reference internal" href="atom_grid.html#Example:-Calculate-Radial-Electron-Density-Distribution">Example: Calculate Radial Electron Density Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="atom_grid.html#Example:-Calculate-Classical-Coulomb-Repulsion-Energy">Example: Calculate Classical Coulomb Repulsion Energy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="molecular_grid_construction.html">Molecular Grid Construction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid_construction.html#Molecular-Grid-Details">Molecular Grid Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid_construction.html#Construction-of-Molecular-Grid">Construction of Molecular Grid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid_construction.html#Constructor">Constructor</a></li>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid_construction.html#from_preset-method">from_preset method</a></li>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid_construction.html#from_size-method">from_size method</a></li>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid_construction.html#from_pruned-method">from_pruned method</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="molecular_grid.html">Molecular Grid Application</a><ul>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid.html#Integration">Integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid.html#Example:-Electron-Density">Example: Electron Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid.html#Local-Properties">Local Properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid.html#Example:-Atomic-charges-from-molecular-electron-density">Example: Atomic charges from molecular electron density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid.html#Interpolation">Interpolation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid.html#id1">Example: Electron Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid.html#Derivative-Interpolation">Derivative Interpolation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid.html#Example:-Weizsacker-Kinetic-Energy-Density">Example: Weizsacker Kinetic Energy Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="molecular_grid.html#Solving-Poisson-Equation">Solving Poisson Equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="molecular_grid.html#Example:-Electrostatic-Potential">Example: Electrostatic Potential</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Cubic Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Tensor-1D-Grids">Tensor 1D Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Example-1:-Interpolation">Example 1: Interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Example-2:-Visualization-of-2p_{z}-Orbital-using-Tensor-1D-Grid">Example 2: Visualization of <span class="math notranslate nohighlight">\(2p_{z}\)</span> Orbital using Tensor 1D Grid</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i.-Utility-Function-For-Plotting-Isosurfaces">i. Utility Function For Plotting Isosurfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii.-Plot-2p_{z}-orbital-from-isosurface-value">ii. Plot <span class="math notranslate nohighlight">\(2p_{z}\)</span> orbital from isosurface value</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Uniform-Grid">Uniform Grid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Example-1:-Constructing-Uniform-Grid-Around-Formaldehyde-Anion">Example 1: Constructing Uniform Grid Around Formaldehyde Anion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Example-2:-Calculate-and-Visualize-Dual-Descriptor-of-Formaldehyde">Example 2: Calculate and Visualize Dual Descriptor of Formaldehyde</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i.-Define-utility-function-to-calculate-the-dual-descriptor">i. Define utility function to calculate the dual descriptor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii.-Calculate-and-visualize-dual-descriptor">ii. Calculate and visualize dual descriptor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Example-3:-Integrate-The-Dual-Descriptor-Domains">Example 3: Integrate The Dual Descriptor Domains</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i.-Define-utility-function-to-extract-dual-descriptor-domains">i. Define utility function to extract dual descriptor domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii.-Select-and-integrate-the-positive-(electrophilic)-domains-of-the-dual-descriptor">ii. Select and integrate the positive (electrophilic) domains of the dual descriptor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iii.-Select-and-integrate-the-negative-(nucleophilic)-domains-of-the-dual-descriptor">iii. Select and integrate the negative (nucleophilic) domains of the dual descriptor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interpolation_poisson.html">Interpolation and Solving Poisson’s Equation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="interpolation_poisson.html#Details">Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="interpolation_poisson.html#Example:-Unit-charge-distribution">Example: Unit-charge distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="interpolation_poisson.html#Solving-Poisson-Equation">Solving Poisson Equation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="multipole_moments.html">Multipole Moments</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pyapi/modules.html">grid</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../pyapi/grid.html">grid package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../pyapi/grid.html#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.angular.html">grid.angular module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.atomgrid.html">grid.atomgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.basegrid.html">grid.basegrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.becke.html">grid.becke module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.cubic.html">grid.cubic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.hirshfeld.html">grid.hirshfeld module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.molgrid.html">grid.molgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.ngrid.html">grid.ngrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.ode.html">grid.ode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.onedgrid.html">grid.onedgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.periodicgrid.html">grid.periodicgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.poisson.html">grid.poisson module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.rtransform.html">grid.rtransform module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pyapi/grid.utils.html">grid.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../pyapi/grid.html#module-grid">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">grid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Cubic Grids</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/cubic_grid.nblink" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><a class="reference external" href="https://colab.research.google.com/github/theochem/grid/blob/master/examples/Cubic_Grids.ipynb"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<div class="section" id="Cubic-Grids">
<h1>Cubic Grids<a class="headerlink" href="#Cubic-Grids" title="Permalink to this heading"></a></h1>
<p>Cubic grids are commonly found in many other packages and are useful for visualization, interpolation and integration purposes.</p>
<p>In Grid, it offers two classes for constructing these cubic (or Hyper-rectangular) grids in three-dimensions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../pyapi/grid.cubic.html#grid.cubic.Tensor1DGrids"><span class="std std-ref">Tensor1DGrids</span></a> : Tensor product of three one-dimensional grids.</p></li>
<li><p><a class="reference internal" href="../pyapi/grid.cubic.html#grid.cubic.UniformGrid"><span class="std std-ref">UniformGrid</span></a> : Evenly spaced grid in three axes.</p></li>
</ul>
<p>See their API documentation for more information about the classes. This example illustrates how to use these grid classes for both visualization, interpolation (including differentiation), and integration, with a focus on usage in quantum chemistry. It is recommended for general usage to use the Tensor1DGrids and for quantum chemistry applications, to use the UniformGrid class.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># # Install packages in Google Colab
# ! pip install qc-iodata
# ! pip install qc-grid
# ! pip install qc-gbasis

# # Download the example files
# from urllib.request import urlretrieve
# urlretrieve(&quot;https://raw.githubusercontent.com/theochem/grid/refs/heads/master/examples/ch2o_q%2B1.fchk&quot;,&quot;ch2o_q+1.fchk&quot;)
# urlretrieve(&quot;https://raw.githubusercontent.com/theochem/grid/refs/heads/master/examples/ch2o_q-1.fchk&quot;,&quot;ch2o_q-1.fchk&quot;)
</pre></div>
</div>
</div>
<div class="section" id="Tensor-1D-Grids">
<h2>Tensor 1D Grids<a class="headerlink" href="#Tensor-1D-Grids" title="Permalink to this heading"></a></h2>
<p>The first grid is a tensor combination of three grids with points <span class="math notranslate nohighlight">\(\{p^1_i\}, \{p^2_i\}, \{p^3_i\}\)</span> and weights <span class="math notranslate nohighlight">\(\{w^1_i\}, \{w^2_i\}, \{w^3_i\}\)</span> such that the new set of points are <span class="math notranslate nohighlight">\(\{(p^1_i, p^2_j, p^3_k)\}\)</span> with weights <span class="math notranslate nohighlight">\(\{w^1_i \times w^2_j \times w^3_k\}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
from grid.onedgrid import UniformInteger
from grid.rtransform import LinearInfiniteRTransform
from grid.cubic import Tensor1DGrids
import numpy as np

limit = 10
# Construct a grid between -10 and 10 on the real line.
npoints = 50
oned_gridx = UniformInteger(npoints)
oned_gridx = LinearInfiniteRTransform(-limit, limit).transform_1d_grid(oned_gridx)

# Construct another grid between -0.5 and 0.5 on the real line
npoints = 45
oned_gridy = UniformInteger(npoints)
oned_gridy = LinearInfiniteRTransform(-limit, limit).transform_1d_grid(oned_gridy)

# Construct another grid between -10 and 10 on the real line
npoints = 55
oned_gridz = UniformInteger(npoints)
oned_gridz = LinearInfiniteRTransform(-limit, limit).transform_1d_grid(oned_gridz)

# Constructing the tensor product grid.
tensor_grid = Tensor1DGrids(oned_gridx, oned_gridy, oned_gridz)
</pre></div>
</div>
</div>
<p>Each of the individual grids axes are plotted.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d

fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.scatter(oned_gridx.points, [0] *  len(oned_gridx.points), [0] *  len(oned_gridx.points), color=&quot;k&quot;, label=&quot;Points on x-axis&quot;)
ax.scatter( [0] *  len(oned_gridy.points), oned_gridy.points, [0] *  len(oned_gridy.points), color=&quot;m&quot;, label=&quot;Points on y-axis&quot;)
ax.scatter( [0] *  len(oned_gridz.points), [0] *  len(oned_gridz.points), oned_gridz.points , color=&quot;b&quot;, label=&quot;Points on z-axis&quot;)
ax.set_xlabel(&quot;X-axis&quot;)
ax.set_ylabel(&quot;Y-axis&quot;)
ax.set_zlabel(&quot;Z-axis&quot;)
plt.legend()
plt.show()
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_6_0.png" src="../_images/notebooks_cubic_grid_6_0.png" />
</div>
</div>
<p>The Tensor1DGrids can now be easily constructed by passing in each of the three one-dimensional grids. These are then plotted</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.scatter(tensor_grid.points[:, 0], tensor_grid.points[:, 1], tensor_grid.points[:, 2], color=&quot;m&quot;, alpha=0.01)
ax.set_xlabel(&quot;X-axis&quot;)
ax.set_ylabel(&quot;Y-axis&quot;)
ax.set_zlabel(&quot;Z-axis&quot;)
plt.title(&quot;Tensor Product of Three One-Dimensional Grids&quot;)
plt.show()

print(f&quot;Points of the grid: {tensor_grid.points}&quot;)
print(f&quot;Weights of the grid: {tensor_grid.weights}.&quot;)
print(f&quot;The number of points: {tensor_grid.size}&quot;)
print(f&quot;The number of dimensions: {tensor_grid.ndim}.&quot;)
print(f&quot;The origin of the grid: {tensor_grid.origin}.&quot;)
print(f&quot;The shape of the grid: {tensor_grid.shape}.&quot;)

# Conversion from indices i to coordinates (i, j, k) to points
coordinate = tensor_grid.index_to_coordinates(5)
print(f&quot;Coordinate of the fifth point: {coordinate}.&quot;)
index = tensor_grid.coordinates_to_index((0, 0, 5))
print(f&quot;Index of the (0, 0, 5) coordinate: {index}.&quot;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_8_0.png" src="../_images/notebooks_cubic_grid_8_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Points of the grid: [[-10.         -10.         -10.        ]
 [-10.         -10.          -9.62962963]
 [-10.         -10.          -9.25925926]
 ...
 [ 10.          10.           9.25925926]
 [ 10.          10.           9.62962963]
 [ 10.          10.          10.        ]]
Weights of the grid: [0.06871435 0.06871435 0.06871435 ... 0.06871435 0.06871435 0.06871435].
The number of points: 123750
The number of dimensions: 3.
The origin of the grid: [-10. -10. -10.].
The shape of the grid: (50, 45, 55).
Coordinate of the fifth point: (0, 0, 5).
Index of the (0, 0, 5) coordinate: 5.
</pre></div></div>
</div>
<div class="section" id="Example-1:-Interpolation">
<h3>Example 1: Interpolation<a class="headerlink" href="#Example-1:-Interpolation" title="Permalink to this heading"></a></h3>
<p>This example will attempt to interpolate a Gaussian, first on a subset of the points used for interpolation then later on random set of points.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># Interpolation of a Gaussian
gaussian = lambda pts: np.exp(-np.linalg.norm(pts, axis=1)**2.0)
gaus_vals = gaussian(tensor_grid.points)

# Interpolation evaluated on subset of the same points used for interpolation
subset = tensor_grid.points[np.random.choice(range(tensor_grid.size), 10)]
true_vals = gaussian(subset)

print(&quot;Interpolate using linear method.&quot;)
interpol = tensor_grid.interpolate(subset, gaus_vals, use_log=False, method=&quot;linear&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)

print(&quot;Interpolate using linear method applying the logarithm.&quot;)
interpol = tensor_grid.interpolate(subset, gaus_vals, use_log=True, method=&quot;linear&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)

print(&quot;Interpolate using cubic splines&quot;)
interpol = tensor_grid.interpolate(subset, gaus_vals, use_log=False, method=&quot;cubic&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)

print(&quot;Inteprolate using cubic splines appling the logarithm&quot;)
interpol = tensor_grid.interpolate(subset, gaus_vals, use_log=True, method=&quot;cubic&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Interpolate using linear method.
The errors are:  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
Maximum error is 0.0

Interpolate using linear method applying the logarithm.
The errors are:  [171.46716217  70.30215474  78.32720365  32.11924387 130.53013235
  28.19417151  35.37443308  85.77553134  85.69913673  26.65532941]
Maximum error is 171.4671621664289

Interpolate using cubic splines
The errors are:  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
Maximum error is 0.0

Inteprolate using cubic splines appling the logarithm
The errors are:  [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
Maximum error is 0.0
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># Interpolate at random set of points
random_pts = np.random.uniform(-1, 1, (25, 3))
true_vals = gaussian(random_pts)

print(&quot;Interpolate using linear method.&quot;)
interpol = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, method=&quot;linear&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)
# The logarithm is first applied to the Gaussian functions to be easier to interpolate at.
print(&quot;Interpolate using linear method applying the logarithm.&quot;)
interpol = tensor_grid.interpolate(random_pts, gaus_vals, use_log=True, method=&quot;linear&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)
# Rather then interpolate using linearly, this used the cubic
print(&quot;Interpolate using cubic splines&quot;)
interpol = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, method=&quot;cubic&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)
# Same as above but the logarithm is applied.
print(&quot;Inteprolate using cubic splines appling the logarithm&quot;)
interpol = tensor_grid.interpolate(random_pts, gaus_vals, use_log=True, method=&quot;cubic&quot;)
print(&quot;The errors are: &quot;, np.abs(interpol - true_vals))
print(f&quot;Maximum error is {np.max(np.abs(interpol - true_vals))} \n&quot;)
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Interpolate using linear method.
The errors are:  [0.01233929 0.00172326 0.01414473 0.00302718 0.03765561 0.00854703
 0.00573863 0.0096147  0.06938564 0.00885821 0.03244877 0.00313253
 0.00879784 0.02016751 0.00573694 0.014182   0.00269118 0.01196634
 0.00416348 0.05229362 0.00944945 0.00436619 0.02369888 0.01221546
 0.03681424]
Maximum error is 0.0693856422879573

Interpolate using linear method applying the logarithm.
The errors are:  [1.5443592  1.71594526 1.34273699 1.80571319 1.18542439 1.62956061
 1.63051993 1.45611032 1.11876818 1.40452868 1.24498067 2.56010903
 1.54114751 1.13349723 1.88518539 1.45877593 1.86029613 1.40771558
 2.29762085 1.07745488 1.60149404 2.39484291 1.27974207 1.19860893
 1.19903943]
Maximum error is 2.560109034575345

Interpolate using cubic splines
The errors are:  [3.86592728e-04 4.22040488e-04 1.66738913e-04 4.13390441e-04
 1.01639001e-03 4.34750401e-05 5.16147392e-05 9.61299995e-05
 1.64110278e-03 5.10977886e-04 1.88314046e-04 1.11520856e-04
 5.16837466e-04 8.08227555e-04 1.77906599e-04 2.64324388e-05
 1.57194487e-04 3.27801023e-04 2.26379162e-04 1.25083661e-03
 2.33331268e-04 4.52028716e-04 3.51733200e-04 8.65339717e-04
 8.68365576e-04]
Maximum error is 0.0016411027780264265

Inteprolate using cubic splines appling the logarithm
The errors are:  [5.55111512e-17 5.55111512e-17 1.66533454e-16 1.11022302e-16
 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.11022302e-16
 1.11022302e-16 0.00000000e+00 0.00000000e+00 4.16333634e-17
 1.11022302e-16 0.00000000e+00 8.32667268e-17 1.66533454e-16
 5.55111512e-17 1.11022302e-16 5.55111512e-17 1.11022302e-16
 1.11022302e-16 1.11022302e-16 1.11022302e-16 1.11022302e-16
 0.00000000e+00]
Maximum error is 1.6653345369377348e-16
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># Derivative can be interpolated
# X-derivative
deriv_x = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, nu_x=1, nu_y=0, nu_z=0, method=&quot;cubic&quot;)
print(f&quot;Derivative in x-direction {deriv_x}.&quot;)
# Y-derivative
deriv_y = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, nu_x=0, nu_y=1, nu_z=0, method=&quot;cubic&quot;)
# Z-derivative
deriv_z = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, nu_x=0, nu_y=0, nu_z=1, method=&quot;cubic&quot;)
# XY- derivative
deriv_xy = tensor_grid.interpolate(random_pts, gaus_vals, use_log=False, nu_x=1, nu_y=1, nu_z=0, method=&quot;cubic&quot;)
# The logarithm can be used to interpolate derivatives on single points only (mixed derivative are not supported)
derivs = []
for pt in random_pts:
    deriv_x = tensor_grid.interpolate(np.array([pt]), gaus_vals, use_log=True, nu_x=1, nu_y=0, nu_z=0, method=&quot;cubic&quot;)
    derivs.append(deriv_x[0])
print(f&quot;Derivative (using logarithm) in x-direction {np.array(derivs)}.&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Derivative in x-direction [ 0.30734258  0.24753392 -0.10164385 -0.35502454  0.62256378 -0.4806336
 -0.27490521  0.64421173  0.50708235 -0.62589627 -0.02271022 -0.18075862
 -0.46666906 -0.35434171 -0.07220761  0.37371807 -0.07209604  0.47252084
  0.18407512 -0.08490725  0.31419978 -0.18812879  0.11677048  0.27183554
  0.00227194].
Derivative (using logarithm) in x-direction [ 0.30673882  0.24715189 -0.1054587  -0.35469932  0.62461378 -0.48053782
 -0.27527774  0.64168648  0.50556283 -0.62694789 -0.02390025 -0.17964052
 -0.46912167 -0.35324203 -0.07340006  0.37428065 -0.07338858  0.4747938
  0.18456838 -0.08932495  0.31453276 -0.18754882  0.12127639  0.27184459
  0.00239627].
</pre></div></div>
</div>
</div>
<div class="section" id="Example-2:-Visualization-of-2p_{z}-Orbital-using-Tensor-1D-Grid">
<h3>Example 2: Visualization of <span class="math notranslate nohighlight">\(2p_{z}\)</span> Orbital using Tensor 1D Grid<a class="headerlink" href="#Example-2:-Visualization-of-2p_{z}-Orbital-using-Tensor-1D-Grid" title="Permalink to this heading"></a></h3>
<p>Given a function <span class="math notranslate nohighlight">\(f(x, y, z)\)</span>, (e.g. an atomic orbital or electron density) we can evaluate it on a cubic grid and visualize the distribution of the function in space using isosurface values. Here we define a function that plots every point in the grid with a corresponding absolute value of the function greater than a threshold value. The function is latter used to visualize the <span class="math notranslate nohighlight">\(2p_{z}\)</span> orbital.</p>
<div class="section" id="i.-Utility-Function-For-Plotting-Isosurfaces">
<h4>i. Utility Function For Plotting Isosurfaces<a class="headerlink" href="#i.-Utility-Function-For-Plotting-Isosurfaces" title="Permalink to this heading"></a></h4>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># Function to plot grid points bigger than a given threshold
def plot_isosurface(
    grid, vals, isovalue, *, both_signs=True, at_data=None, noticks=False, title=None
):
    &quot;&quot;&quot;Plot grid points with values bigger than isovalue.

    The function plots the grid points with absolute values bigger than isovalue.

    Parameters
    ----------
    grid : Grid
        Cartesian grid (it can be uniform or TensorProductGrid) with 3 dimensions.
    vals : ndarray
        Values of the function on the grid points.
    isovalue : float
        Value of the isosurface to plot.
    both_signs : bool, optional
        If True, plot points with negative values too. The default is True.
    at_data : tuple, optional
        Tuple containing the atomic coordinates and atomic labels. If not None,
        it should be a tuple containing (atcoords, atlabels) where atcoords is
        a ndarray of shape (natoms, 3) containing the atomic coordinates in
        bohr and atlabels is a list of length natoms containing the atomic labels.
    title : str, optional
        Title of the plot. The default is None.
    &quot;&quot;&quot;
    # indices of points with values close to isovalue
    idx_p_vals = np.where(vals &gt; isovalue)
    idx_n_vals = np.where(vals &lt; -isovalue)

    # points with values close to isovalue
    p_pts = grid.points[idx_p_vals]
    n_pts = grid.points[idx_n_vals]

    xmin, xmax = np.min(grid.points[:, 0]), np.max(grid.points[:, 0])
    ymin, ymax = np.min(grid.points[:, 1]), np.max(grid.points[:, 1])
    zmin, zmax = np.min(grid.points[:, 2]), np.max(grid.points[:, 2])

    fig = plt.figure()
    ax = plt.axes(projection=&quot;3d&quot;)
    if noticks:
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_zticks([])

    if at_data is not None:
        if len(at_data) != 2:
            raise ValueError(&quot;at_data should be a tuple containing (atcoords, atlabels)&quot;)

        atcoords, atlabels = at_data
        if atcoords.shape[0] != len(atlabels):
            raise ValueError(&quot;atcoords and atlabels should have the same length&quot;)

        # if there are more than 2 atoms set the view point perpendicular to the molecular plane
        if len(atlabels) &gt; 2:
            # Calculate the centroid of atomic coordinates
            centroid = np.mean(atcoords, axis=0)
            # Center the atomic coordinates by subtracting the centroid from each point
            centered_coords = atcoords - centroid
            # Perform Singular Value Decomposition (SVD) on the centered coordinates
            _, _, V = np.linalg.svd(centered_coords)
            # The normal vector the molecular plane is the last column of the V matrix
            normal_vector = V[-1]
            # Set the view point perpendicular to the plane
            ax.view_init(
                elev=np.degrees(np.arcsin(normal_vector[2])),
                azim=np.degrees(np.arctan2(normal_vector[1], normal_vector[0])),
            )

        # plot the atomic centers
        for i in range(len(atlabels)):
            ax.text(
                atcoords[i, 0],
                atcoords[i, 1],
                atcoords[i, 2],
                atlabels[i],
                color=&quot;k&quot;,
                fontsize=12,
                horizontalalignment=&quot;center&quot;,
                verticalalignment=&quot;center&quot;,
            )
    # set axis limits
    ax.set_xlim((xmin, xmax))
    ax.set_ylim((ymin, ymax))
    ax.set_zlim((zmin, zmax))

    # plot points with values bigger than isovalue
    ax.scatter(
        p_pts[:, 0], p_pts[:, 1], p_pts[:, 2], alpha=0.01, color=&quot;r&quot;, label=f&quot;Positive values&quot;
    )
    if both_signs:
        ax.scatter(
            n_pts[:, 0], n_pts[:, 1], n_pts[:, 2], alpha=0.01, color=&quot;b&quot;, label=f&quot;Negative values&quot;
        )
    legend = plt.legend(loc=&quot;upper right&quot;)
    for lh in legend.get_lines():
        lh.set_alpha(1)
    if title is not None:
        plt.title(title)
    plt.show()
</pre></div>
</div>
</div>
</div>
<div class="section" id="ii.-Plot-2p_{z}-orbital-from-isosurface-value">
<h4>ii. Plot <span class="math notranslate nohighlight">\(2p_{z}\)</span> orbital from isosurface value<a class="headerlink" href="#ii.-Plot-2p_{z}-orbital-from-isosurface-value" title="Permalink to this heading"></a></h4>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
import numpy as np

# define 2pz orbital function
def psi_2pz(x, y, z, a_0):
    r = np.sqrt(x**2 + y**2 + z**2)
    return np.exp(-r / (2 * a_0)) * z


# Evaluate the function on the grid.
psi_vals = psi_2pz(*tensor_grid.points.T, a_0=1.0)

point_idx = target_x = 0.15
tolerance = 1e-2

plot_isosurface(tensor_grid, psi_vals, target_x, title=&quot;$2p_{z}$ Isosurface (0.15 a.u.)&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_17_0.png" src="../_images/notebooks_cubic_grid_17_0.png" />
</div>
</div>
</div>
</div>
</div>
<div class="section" id="Uniform-Grid">
<h2>Uniform Grid<a class="headerlink" href="#Uniform-Grid" title="Permalink to this heading"></a></h2>
<p>This is type of cubic grid (a.k.a. rectilinear grid) with evenly-spaced points in each axes. It supports the same properties and functions as Tensor1DGrids.</p>
<div class="section" id="Example-1:-Constructing-Uniform-Grid-Around-Formaldehyde-Anion">
<h3>Example 1: Constructing Uniform Grid Around Formaldehyde Anion<a class="headerlink" href="#Example-1:-Constructing-Uniform-Grid-Around-Formaldehyde-Anion" title="Permalink to this heading"></a></h3>
<p>This example illustates the use of Grid with the <a class="reference external" href="https://github.com/theochem/iodata">IOData</a> package to construct a default grid around a molecule. The easiest method to do so is the “from_molecule” method. This example will showcase this for Formaldehyde anion. The <code class="docutils literal notranslate"><span class="pre">.fchk</span></code> files of which are read using the <a class="reference external" href="https://github.com/theochem/iodata">IOData</a> package and the <code class="docutils literal notranslate"><span class="pre">.fchk</span></code> files are included in <code class="docutils literal notranslate"><span class="pre">doc/notebooks/ch2o_q-1.fchk</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>from iodata import load_one

# Load the wavefunction information about ch2o
mol_anion = load_one(&quot;ch2o_q-1.fchk&quot;)

# Get the atomic coordinates and numbers
atcoords = mol_anion.atcoords
atnums = mol_anion.atnums
print(f&quot;Atomic Coordinates \n {atcoords}&quot;)
print(f&quot;Atomic Numbers: \n {atnums}&quot;)

fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.scatter(atcoords[:, 0], atcoords[:, 1], atcoords[:, 2], color=&quot;k&quot;, s=50)
ax.set_xlabel(&quot;X-axis&quot;)
ax.set_ylabel(&quot;Y-axis&quot;)
ax.set_zlabel(&quot;Z-axis&quot;)
plt.title(&quot;Atomic coordinates of Formaldehyde.&quot;)
plt.show()
<br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Atomic Coordinates
 [[-1.23259516e-32  1.00530930e-32  1.27229733e+00]
 [ 0.00000000e+00 -1.32254311e-32 -9.95825669e-01]
 [ 0.00000000e+00  1.77311490e+00 -2.10171229e+00]
 [-2.17143949e-16 -1.77311490e+00 -2.10171229e+00]]
Atomic Numbers:
 [8 6 1 1]
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_20_1.png" src="../_images/notebooks_cubic_grid_20_1.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>from grid.cubic import UniformGrid

# Construct uniform grid
uniform_grid = UniformGrid.from_molecule(atnums, atcoords, spacing=0.1, extension=2.0, rotate=True)


print(f&quot;The number of points: {uniform_grid.size}&quot;)
print(f&quot;The number of dimensions: {uniform_grid.ndim}.&quot;)
print(f&quot;The shape of the grid: {uniform_grid.shape}.&quot;)
print(f&quot;The origin of the grid: {uniform_grid.origin}.&quot;)
print(f&quot;The axes of the grid: {uniform_grid.axes}.&quot;)


fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.scatter(atcoords[:, 0], atcoords[:, 1], atcoords[:, 2], color=&quot;k&quot;, s=50)
ax.scatter(uniform_grid.points[:, 0], uniform_grid.points[:, 1], uniform_grid.points[:, 2], color=&quot;m&quot;, alpha=0.01)
ax.set_xlabel(&quot;X-axis&quot;)
ax.set_ylabel(&quot;Y-axis&quot;)
ax.set_zlabel(&quot;Z-axis&quot;)
plt.title(&quot;Atomic coordinates of Formaldehyde.&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The number of points: 224960
The number of dimensions: 3.
The shape of the grid: [74 76 40].
The origin of the grid: [-2.   3.8 -3.7].
The axes of the grid: [[ 0.00000000e+00  0.00000000e+00  1.00000000e-01]
 [ 0.00000000e+00 -1.00000000e-01  0.00000000e+00]
 [ 1.00000000e-01  1.11022302e-17  0.00000000e+00]].
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_21_1.png" src="../_images/notebooks_cubic_grid_21_1.png" />
</div>
</div>
</div>
<div class="section" id="Example-2:-Calculate-and-Visualize-Dual-Descriptor-of-Formaldehyde">
<h3>Example 2: Calculate and Visualize Dual Descriptor of Formaldehyde<a class="headerlink" href="#Example-2:-Calculate-and-Visualize-Dual-Descriptor-of-Formaldehyde" title="Permalink to this heading"></a></h3>
<p>This example will illusrate on how to use UniformGrid to compute and visualize the dual descriptor of formaldehyde. The dual descriptor is a function of electron density and its derivatives and is defined as:</p>
<div class="math notranslate nohighlight">
\[f^{(2)}(r) = \Delta f(r) = (f^{+}(r) - f^{-}(r)\]</div>
<p>where <span class="math notranslate nohighlight">\(f^{+}(r)\)</span> and <span class="math notranslate nohighlight">\(f^{-}(r)\)</span> are the Fukui functions defined as:</p>
<div class="math notranslate nohighlight">
\[f^{+}(r) = \left(\frac{\partial \rho(r)}{\partial \rho^2}\right)^{+}_{\upsilon(r)} = \rho_{N+1}(r) - \rho_{N}(r)\]</div>
<div class="math notranslate nohighlight">
\[f^{-}(r) = \left(\frac{\partial \rho(r)}{\partial \rho^2}\right)^{-}_{\upsilon(r)} = \rho_{N}(r) - \rho_{N-1}(r)\]</div>
<p>then <span class="math notranslate nohighlight">\(f^{(2)}(r)\)</span> can be written as:</p>
<div class="math notranslate nohighlight">
\[f^{(2)}(r) = \rho_{N+1}(r) - \rho_{N-1}(r)\]</div>
<div class="section" id="i.-Define-utility-function-to-calculate-the-dual-descriptor">
<h4>i. Define utility function to calculate the dual descriptor<a class="headerlink" href="#i.-Define-utility-function-to-calculate-the-dual-descriptor" title="Permalink to this heading"></a></h4>
<p>The dual descriptor is evaluated at each grid point as the difference between the electron density of the anion and cation of formaldehyde. The electron density can be evaluated in the grid points using the <a class="reference external" href="https://github.com/theochem/gbasis">GBasis</a> package with the wavefunction read, as above.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>from gbasis.evals.density import evaluate_density

# define function to compute dual descriptor on a grid
def compute_dual_descriptor(grid, rdm_an, rdm_cat, basis_an, basis_cat):
    &quot;&quot;&quot;Compute dual descriptor on a grid.

    Parameters
    ----------
    grid : Grid
        Grid object.
    rdm_an : np.ndarray
        1-RDM of the anion.
    rdm_cat : np.ndarray
        1-RDM of the cation.
    basis_an : list
        Basis set of the anion.
    basis_cat : list
        Basis set of the cation.
    &quot;&quot;&quot;
    # evaluate electron density of cation and anion on the grid
    dens_vals_cat = evaluate_density(rdm_cat, basis_cat, grid.points)
    dens_vals_an = evaluate_density(rdm_an, basis_an, grid.points)

    # compute dual descriptor on the grid
    return dens_vals_an - dens_vals_cat
</pre></div>
</div>
</div>
</div>
<div class="section" id="ii.-Calculate-and-visualize-dual-descriptor">
<h4>ii. Calculate and visualize dual descriptor<a class="headerlink" href="#ii.-Calculate-and-visualize-dual-descriptor" title="Permalink to this heading"></a></h4>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>from iodata import load_one
from gbasis.wrappers import from_iodata

# load formaldehyde cation and anion fchk files
mol_cation = load_one(&quot;ch2o_q+1.fchk&quot;)

# Construct molecular basis from wave-function information read by IOData
basis_cat = from_iodata(mol_cation)
basis_an = from_iodata(mol_anion)

# get rdms for cation and anion
rdm_cat = mol_cation.one_rdms[&quot;scf&quot;]
rdm_an = mol_anion.one_rdms[&quot;scf&quot;]

# compute dual descriptor on the grid
dd = compute_dual_descriptor(uniform_grid, rdm_an, rdm_cat, basis_an, basis_cat)

# plot dual descriptor isosurface
mol_data = (atcoords, [&quot;O&quot;, &quot;C&quot;, &quot;H&quot;, &quot;H&quot;])
plot_isosurface(
    uniform_grid, dd, 0.03, at_data=mol_data, title=&quot;Dual Descriptor Isosurface&quot;, noticks=True
)

print(f&quot;Positive values (red) correspond to nucleophilic regions&quot;)
print(f&quot;Negative values (blue) correspond to electrophilic regions&quot;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_26_0.png" src="../_images/notebooks_cubic_grid_26_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Positive values (red) correspond to nucleophilic regions
Negative values (blue) correspond to electrophilic regions
</pre></div></div>
</div>
</div>
</div>
<div class="section" id="Example-3:-Integrate-The-Dual-Descriptor-Domains">
<h3>Example 3: Integrate The Dual Descriptor Domains<a class="headerlink" href="#Example-3:-Integrate-The-Dual-Descriptor-Domains" title="Permalink to this heading"></a></h3>
<p>All classes in <a class="reference external" href="https://github.com/theochem/grid">Grid</a> offers an easy method to integrate. Here we integrate the different lobes of the dual descriptor. This can be used to assess the relevance of electrophilic and nucleophilic regions of the molecule.</p>
<div class="section" id="i.-Define-utility-function-to-extract-dual-descriptor-domains">
<h4>i. Define utility function to extract dual descriptor domains<a class="headerlink" href="#i.-Define-utility-function-to-extract-dual-descriptor-domains" title="Permalink to this heading"></a></h4>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># define utility function for grouping grid points in domains
from itertools import combinations
from scipy.sparse.csgraph import connected_components


# function to get grid points indices for same sign connected points with absolute
# value  greater than a threshold (select domain defined by isovalue)
def get_domains(grid, vals, isovalue):
    &quot;&quot;&quot;Get grid points indices for domains with same sign connected points.

    The function returns the indices of the grid points that belong to the same domain. A domain
    is defined by a set of connected points with the same sign and absolute value greater than
    isovalue.

    Parameters
    ----------
    grid : Grid
        Cartesian grid (it can be uniform or TensorProductGrid) with 3 dimensions.
    vals : ndarray
        Values of the function on the grid points.
    isovalue : float
        Value of the isosurface used to define the domains.

    Returns
    -------
    tuple
        Tuple containing two lists. The first list contains domains with positive values and the
        second list contains domains with negative values. Each domain is a np.array with the
        indexes of the grid points that belong to the same domain.
    &quot;&quot;&quot;
    # indices of points with value modulus greater than isovalue
    idx_p_vals = np.where(vals &gt; isovalue)[0]  # positive values
    idx_n_vals = np.where(vals &lt; -isovalue)[0]  # negative values

    # create adjacency matrix selected points with same sign
    p_vals_adj = np.zeros((len(idx_p_vals), len(idx_p_vals)))
    n_vals_adj = np.zeros((len(idx_n_vals), len(idx_n_vals)))

    # try all combinations of selected points with same sign (positive values)
    for i, j in combinations(range(len(idx_p_vals)), 2):
        # get coordinate indices of the points
        i_coord_idx = np.array(grid.index_to_coordinates(idx_p_vals[i]))
        j_coord_idx = np.array(grid.index_to_coordinates(idx_p_vals[j]))
        # two points are adjacent if they differ by at most 1 in each coordinate index
        if np.max(np.abs(i_coord_idx - j_coord_idx)) == 1:
            p_vals_adj[i, j] = 1

    # try all combinations of selected points with same sign (negative values)
    for i, j in combinations(range(len(idx_n_vals)), 2):
        i_coord_idx = np.array(grid.index_to_coordinates(idx_n_vals[i]))
        j_coord_idx = np.array(grid.index_to_coordinates(idx_n_vals[j]))
        # two points are adjacent if they differ by at most 1 in each coordinate
        if np.max(np.abs(i_coord_idx - j_coord_idx)) == 1:
            n_vals_adj[i, j] = 1

    # returns an array of integers, each integer represents domain and the indexes where
    # it appear are the points belonging to that domain
    # example: [0,1,0,0,1,1] -&gt; points 0,2,3 belong to domain 0
    #                        -&gt; points 1,4,5 belong to domain 1
    p_groups = connected_components(p_vals_adj, directed=False)[1]
    n_groups = connected_components(n_vals_adj, directed=False)[1]

    # creates a list with the domains. Each element of the list is a np.array with the indexes
    # of the selected points that belong to the same domain.
    # example: [0,1,0,0,1,1] -&gt; [[0,2,3],[1,4,5]]
    p_domains = list([np.where(p_groups == i)[0] for i in range(max(p_groups) + 1)])
    n_domains = list([np.where(n_groups == i)[0] for i in range(max(n_groups) + 1)])

    # transform indexes of selected points to indexes of all grid points for each domain
    p_domains = [idx_p_vals[domain] for domain in p_domains]
    n_domains = [idx_n_vals[domain] for domain in n_domains]

    return p_domains, n_domains
</pre></div>
</div>
</div>
</div>
<div class="section" id="ii.-Select-and-integrate-the-positive-(electrophilic)-domains-of-the-dual-descriptor">
<h4>ii. Select and integrate the positive (electrophilic) domains of the dual descriptor<a class="headerlink" href="#ii.-Select-and-integrate-the-positive-(electrophilic)-domains-of-the-dual-descriptor" title="Permalink to this heading"></a></h4>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span># get dual descriptor domains, integrate and plot them
p_domains, n_domains = get_domains(uniform_grid, dd, 0.03)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>for domain in p_domains:
    domain_vals = dd.copy()
    domain_mask = np.isin(np.arange(len(dd)), domain, invert=True)
    domain_vals[domain_mask] = 0.0

    plot_isosurface(
        uniform_grid,
        domain_vals,
        0.001,
        at_data=mol_data,
        title=f&quot;Domain   Integral: {uniform_grid.integrate(domain_vals):.3f}&quot;,
        noticks=True,
    )
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_0.png" src="../_images/notebooks_cubic_grid_32_0.png" />
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_1.png" src="../_images/notebooks_cubic_grid_32_1.png" />
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_2.png" src="../_images/notebooks_cubic_grid_32_2.png" />
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_3.png" src="../_images/notebooks_cubic_grid_32_3.png" />
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_4.png" src="../_images/notebooks_cubic_grid_32_4.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_32_5.png" src="../_images/notebooks_cubic_grid_32_5.png" />
</div>
</div>
</div>
<div class="section" id="iii.-Select-and-integrate-the-negative-(nucleophilic)-domains-of-the-dual-descriptor">
<h4>iii. Select and integrate the negative (nucleophilic) domains of the dual descriptor<a class="headerlink" href="#iii.-Select-and-integrate-the-negative-(nucleophilic)-domains-of-the-dual-descriptor" title="Permalink to this heading"></a></h4>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython2 notranslate"><div class="highlight"><pre><span></span>for domain in n_domains:
    domain_vals = dd.copy()
    domain_mask = np.isin(np.arange(len(dd)), domain, invert=True)
    domain_vals[domain_mask] = 0.0

    plot_isosurface(
        uniform_grid,
        domain_vals,
        0.001,
        at_data=mol_data,
        title=f&quot;Domain Integral: {uniform_grid.integrate(domain_vals):.3f}&quot;,
        noticks=True,
    )
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_34_0.png" src="../_images/notebooks_cubic_grid_34_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_cubic_grid_34_1.png" src="../_images/notebooks_cubic_grid_34_1.png" />
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="molecular_grid.html" class="btn btn-neutral float-left" title="Molecular Grids" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="interpolation_poisson.html" class="btn btn-neutral float-right" title="Interpolation and Solving Poisson’s Equation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, QC-Devs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>